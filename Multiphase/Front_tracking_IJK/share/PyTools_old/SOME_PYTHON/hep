8c8
< import pandas
---
> # import pandas
12c12
< 
---
> import DNSTools3 as dtool
21c21,23
<     Dev in progress. Travailler sur la fiche qui se trouve ici :
---
>     Construit les termes du bilan de qdm : convection; diffusion; interfaces; maj de rho; ...
>     Travailler sur la fiche qui se trouve ici :
>     /volatile/DERIVE_Y/BULLE_X/SIGMA_NON_NUL_RK3
26,27c28,29
< # mode d'emploi : python use_check_etapes_et_termes_III.py nom_fig chemin_out directions  N_smooth [temps0,temps1]
< #                                0                        1        2        3          4         5
---
> # mode d'emploi : python use_check_etapes_et_termes_V.py nom_fig chemin_out jdd directions  N_smooth [temps0,temps1]
> #                                0                           1        2       3       4         5         6
38,39c40,46
< Tracons la QDM et les forces interfaciales au cours du temps \n\
< ##############################################"
---
>         Tracons les termes du bilan de QDM et les forces interfaciales au cours du temps \n\
>         -> dt C\n\
>         -> dt D\n\
>         -> dt I\n\
>         -> dt P\n\
>         -> (r^{n+1} - r^{n}) u \n\
>         ##############################################"
45,46c52,54
< directions = sys.argv[3]
< N_smooth = float(sys.argv[4])
---
> fichier_data = sys.argv[3]
> directions = sys.argv[4]
> N_smooth = float(sys.argv[5])
48c56
< t_deb, t_fin = float(sys.argv[5].rstrip("]").lstrip("[").split(",")[-2]),float(sys.argv[5].rstrip("]").lstrip("[").split(",")[-1])
---
> t_deb, t_fin = float(sys.argv[6].rstrip("]").lstrip("[").split(",")[-2]),float(sys.argv[6].rstrip("]").lstrip("[").split(",")[-1])
54,55d61
< print("shape")
< print(numpy.loadtxt(glob.glob(chemin_out)[-1]).shape)
66a73,102
> ########################################################################
> 
> ########################################################################
> # Pierre de Rosette pour savoir quelle colonne correspond à quelle grandeur
> #              car dans le cas d'une reprise il se peut que l'on perde cette information
> #              meme dans le cas d'un calcul initial, il a de fortes chances pour que ce
> #              ne soit pas "bien" fait.
> ########################################################################
> rosette = { "it":0,
>         "t":1,
>         "rk":2,
>         "ru_av_pred"         : {"x":3,  "y":4,  "z":5},   # rho_u_euler_av_pred
>         "rdu_ap_pred"        : {"x":6,  "y":7,  "z":8},   # rho_du_euler_ap_pred
>         "ru_ap_proj"         : {"x":9,  "y":10, "z":11},  # rho_u_euler_av_prediction
>         "rdu_ap_proj"        : {"x":12, "y":13, "z":14},  # rho_du_euler_ap_prediction
>         "ru_av_rmi"          : {"x":15, "y":16, "z":17},  # rho_u_euler_av_rho_mu_ind
>         "ru_ap_rmi"          : {"x":18, "y":19, "z":20},  # rho_u_euler_ap_rho_mu_ind
>         "u_ap_rmi"           : {"x":21, "y":22, "z":23},  # u_euler_ap_rho_mu_ind
>         "t_intf"             : {"x":24, "y":25, "z":26},  # terme_interfaces               /!\/!\ il est nul celui-là, on le remplit que sous certaines conditions... ne le regardons pas
>         "t_conv"             : {"x":27, "y":28, "z":29},  # terme_convection : defaut -> Moyenne_spatiale{ \rho S [u_i u_j] }   @\rho du/dt
>         "t_diff"             : {"x":30, "y":31, "z":32},  # terme_diffusion : defaut -> Moyenne_spatiale{ S [\mu s_{ij}] } *    @\rho du/dt
>         "t_pr_2"             : {"x":33, "y":34, "z":35},  # terme_pression_bis : Moyenne_spatiale{ grad(p*) }                   @\rho du/dt
>         "t_pr_3"             : {"x":36, "y":37, "z":38},  # terme_pression_bis : Moyenne_spatiale{ 1/rho * grad(p*) }           @     du/dt
> 
>         "t_intf_bf_ms_bis"   : {"x":39, "y":40, "z":41},  # terme_interfaces_bf_mass_solveur_bis : Moyenne_spatiale{ dv-tc-td }                 @\rho du/dt
>         "t_intf_bf_ms"       : {"x":42, "y":43, "z":44},  # terme_interfaces_bf_mass_solver : Moyenne_spatiale{ terme_source_interfaces_ns_ }   @\rho du/dt
>         "t_intf_af_ms"       : {"x":45, "y":46, "z":47},  # terme_interfaces_af_mass_solver : Moyenne_spatiale{ terme_source_interfaces_ns_ }   @      du/dt (le mass_solver a ete applique)
>         "pres_ap_proj"       : {"x":48, "y":48, "z":48},  # pression_ap_proj, ce n'est qu'UN double
>         "t_conv_mass_sol"    : {"x":52, "y":53, "z":54},  # terme_moyen_convection_mass_solver_ : Moyenne_spatiale{ 1/rho * C }  @      du/dt
>         "t_diff_mass_sol"    : {"x":55, "y":56, "z":57}}  # terme_moyen_diffusion_mass_solver_  : Moyenne_spatiale{ 1/rho * D }  @      du/dt
67a104,138
> color = {"x":"r","y":"g","z":"b"}
> linestyle = ["solid", "dashed", "dotted", "dashdot","loosely dashed"]
> ########################################################################
> check = numpy.loadtxt(glob.glob(chemin_out)[-1])
> ########################################################################
> if 2 in check[:,[rosette["rk"]]] :
>     ## Le schema temporel de resolution est RK3
>     print("# RK3 SIMULATION")
>     rk3 = True
>     indices_temps_rk3_2 = numpy.argwhere(check[:,[rosette["rk"]]]==2)[:,0]
>     print("check[indices_temps_rk3_2[0],:3]",check[indices_temps_rk3_2[0],:3])
>     temps_2 =  check[indices_temps_rk3_2,[rosette["t"]]]
>     print("temps_2[0:5]",temps_2[0:5])
>     # Version de MON_IJK anterieure au 24 juin : Le t en RK3 est mal ecrit
>     # avec la mauvaise ecriture : 
>     #     rk3 = 1 donne t1 = t + 5/12 dt
>     #     rk3 = 0 donne t0 = t + 4/12 dt d'ou l'expression de dt
>     mal_ecrit = False 
>     if mal_ecrit:
>         indices_temps_rk3_0 = numpy.argwhere(check[:,[rosette["rk"]]]==0)[:,0]
>         indices_temps_rk3_1 = numpy.argwhere(check[:,[rosette["rk"]]]==1)[:,0]
>         dt = 12. * (check[indices_temps_rk3_1 ,[rosette["t"]]] - check[indices_temps_rk3_0 ,[rosette["t"]]])
>         # Puis les "bon" ti sont :
>         #         t0 = t  + 4/12 dt        : inchange
>         #         t1 = t0 + 5/12 dt        : change
>         #         t2 = t1 + 3/12 dt = t+dt : change
>         # /!\ La, on "peut" se contenter de faire comme ca car le out commence bien pas un rk_step = 0. Si ce n'etait pas le cas, 
>         # /!\ il faudrai certainement se casser plus la tete pour bien faire. Dans la mesure ou c'est juste pour corriger une etourderie... on se casse pas plus 
>         # Et paf, on remet les bonnes valeurs dans nos tableaux de temps, direct
>         temps_0 = check[indices_temps_rk3_0 ,[rosette["t"]]]
>         temps_1 = temps_0 + 5./12. * dt
>         check[indices_temps_rk3_1 ,[rosette["t"]]] = temps_1
>         temps_2 = temps_1 + 3./12. * dt
>         check[indices_temps_rk3_2 ,[rosette["t"]]] = temps_2
>         # temps   = temps_2
68a140,144
> else:
>     ## Le schema temporel de resolution est EUler explicite
>     print("# EULER EXPLICIT SIMLATION")
>     rk3 = False
> temps = check[:,rosette["t"]]
70a147
> ########################################################################
71a149,150
> # /!\ dans le cas de RK3, it_deb/fin sont plutot ligne_deb/fin
> ########################################################################
73,74c152,153
< # Si es instants renseignés ne sont pas inclus dans la plage de releves
< #   -> l'instant initial est le prmeier instant de releve. L'instant final est le dernier instant de releve
---
> # Si les instants renseignés ne sont pas inclus dans la plage de releves
> #   -> l'instant initial est le premier instant de releve. L'instant final est le dernier instant de releve
76a156
> 
78a159,168
> #print("1 : ", it_deb)
> if rk3:
>     # On souhaite que les tableaux commencent par un rk_step = 2. Un point c'est out
>     it=it_deb[0][0]
>     vrai_it_deb = numpy.argwhere( numpy.abs(temps_2-temps[it]) == numpy.min(numpy.abs(temps_2-temps[it])))[0][0]
>     #print("vrai_it_deb : ",vrai_it_deb)
>     vrai_t_deb = temps_2[vrai_it_deb]
>     #print("vrai_t_deb : ",vrai_t_deb)
>     it_deb = numpy.argwhere(numpy.abs(temps-vrai_t_deb)==numpy.min(numpy.abs(temps-vrai_t_deb)))
> #/!\ il faut sans doute faire la meme chose pour it_fin si le fichier out ne se termine pas par un rk = 2
79a170
> 
85a177
> 
91c183
< print(it_deb, it_fin)
---
> print("# it_deb = %s \n# it_fin = %s"%(it_deb, it_fin))
92a185
> print("# t_deb = %s \n# t_fin = %s"%(temps[0], temps[-1]))
94,116d186
< # Pierre de Rosette pour savoir quelle colonne correspond à quelle grandeur
< #              car dans le cas d'une reprise il se peut que l'on perde cette information
< #              meme dans le cas d'un calcul initial, il a de fortes chances pour que ce
< #              ne soit pas "bien" fait.
< ########################################################################
< rosette = { "it":0,
<             "t":1,
<             "rk":2,
<             "ru_av_pred"         : {"x":3,  "y":4,  "z":5},   # rho_u_euler_av_pred
<             "rdu_ap_pred"        : {"x":6,  "y":7,  "z":8},   # rho_du_euler_ap_pred
<             "ru_ap_proj"         : {"x":9,  "y":10,  "z":11},  # rho_u_euler_av_prediction
<             "rdu_ap_proj"        : {"x":12, "y":13, "z":14},  # rho_du_euler_ap_prediction
<             "ru_av_rmi"          : {"x":15, "y":16, "z":17},  # rho_u_euler_av_rho_mu_ind
<             "ru_ap_rmi"          : {"x":18, "y":19, "z":20},  # rho_u_euler_ap_rho_mu_ind
<             "u_ap_rmi"           : {"x":21, "y":22, "z":23},  # u_euler_ap_rho_mu_ind
<             "t_intf"             : {"x":24, "y":25, "z":26},  # terme_interfaces               /!\/!\ il est nul celui-là, on le remplit que sous certaines conditions... ne le regardons pas
<             "t_conv"             : {"x":27, "y":28, "z":29},  # terme_convection
<             "t_diff"             : {"x":30, "y":31, "z":32},  # terme_diffusion
<             "t_pres"             : {"x":33, "y":34, "z":35},  # terme_pression_bis  /!\/!\ terme_pression (sans le bis) est naze : il est non nul que si flag ";;; in p ustar" actif
<             "t_intf_bf_ms_bis"   : {"x":36, "y":37, "z":38},  # terme_interfaces_bf_mass_solveur_bis : a partir de d_velocity_, terme_convection et terme_diffusion
<             "t_intf_bf_ms"       : {"x":39, "y":40, "z":41},  # terme_interfaces_bf_mass_solveur : directement a partir de terme_source_interfaces_ns_
<             "t_intf_af_ms"       : {"x":42, "y":43, "z":44},  # terme_interfaces_af_mass_solveur terme d'interfaces directement a partir de terme_source_interfaces_ns_ et apres division par rho et volume cellule
<             "pres_ap_proj"       : {"x":45, "y":45, "z":45}}  # pression_ap_proj, ce n'est qu'UN double
118,119c188
< color = {"x":"r","y":"g","z":"b"}
< linestyle = ["solid", "dashed", "dotted", "dashdot","loosely dashed"]
---
> 
120a190,254
> # On recupere uniquement les instants 'utiles' (en RK3, un pas sur trois avance réellement le temps)
> # Dans IJK on a bien pris garde à faire un += quand il faut faire le += 
> # /!\ ==> En schéma RK3 c'est la galère, on va construire les termes du bilan :
> #                      terme_1 = (a0 * temre^{n}) + (a1 * terme^{n+1/3}) + (a2 * terme^{n+2/3})
> 
> if 2 in check[it_deb:it_fin,[rosette["rk"]]] :
>     print("# RK3 SIMULATION")
>     print("check[it_deb,:]",check[it_deb,:3])
>     rk3 = True
>     # On prend pour refernce de depart le rk = 2, il est attache a l'iteration precedent rk = 1
>     indices_temps_rk3_2 = numpy.argwhere(check[it_deb:it_fin,[rosette["rk"]]]==2)[:,0] # je ne suis pas trop sur, mais ce doit etre une histoire que le decompte commence pas pareil pour tous   
>     indices_temps_rk3_0 = numpy.argwhere(check[it_deb:it_fin,[rosette["rk"]]]==0)[:,0] # je ne suis pas trop sur, mais ce doit etre une histoire que le decompte commence pas pareil pour tous
>     indices_temps_rk3_1 = numpy.argwhere(check[it_deb:it_fin,[rosette["rk"]]]==1)[:,0] # je ne suis pas trop sur, mais ce doit etre une histoire que le decompte commence pas pareil pour tous
> 
>     print("indices_temps_rk3_0[0:3]",indices_temps_rk3_0[0:3])
>     print("indices_temps_rk3_1[0:3]",indices_temps_rk3_1[0:3])
>     print("indices_temps_rk3_2[0:3]",indices_temps_rk3_2[0:3])
> 
>     print("indices_temps_rk3_0[-3:]",indices_temps_rk3_0[-3:])
>     print("indices_temps_rk3_1[-3:]",indices_temps_rk3_1[-3:])
>     print("indices_temps_rk3_2[-3:]",indices_temps_rk3_2[-3:])
> 
>     check_0 = check[indices_temps_rk3_0,...]
>     check_1 = check[indices_temps_rk3_1,...]
>     check_2 = check[indices_temps_rk3_2,...]
>     
>     print("check_0[0,0:3]",check_0[0,0:3])
>     print("check_1[0,0:3]",check_1[0,0:3])
>     print("check_2[0,0:3]",check_2[0,0:3])
> 
>     print("check_0.shape",check_0.shape)
>     print("check_1.shape",check_1.shape)
>     print("check_2.shape",check_2.shape)
>     
>     # Coefficients specifiques au RK3 de IJK, pour ecrire
>     #     v = dt * (dv_0 * a_0 + dv_1 * a_1 + dv_2 * a_2)
>     alpha_0 = 1./3. - 25./48. + (153*8.)/(9.*28*3)
>     alpha_1 = 45/48. - (153*8.)/(128.*15)
>     alpha_2 = 8/15.
> 
>     check_drho_u = (
>             alpha_0 * (check_0[:,rosette["ru_av_rmi"]["x"]:rosette["ru_av_rmi"]["z"]+1] - check_0[:,rosette["ru_ap_rmi"]["x"]:rosette["ru_ap_rmi"]["z"]+1]) + 
>             alpha_1 * (check_1[:,rosette["ru_av_rmi"]["x"]:rosette["ru_av_rmi"]["z"]+1] - check_1[:,rosette["ru_ap_rmi"]["x"]:rosette["ru_ap_rmi"]["z"]+1]) + 
>             alpha_2 * (check_2[:,rosette["ru_av_rmi"]["x"]:rosette["ru_av_rmi"]["z"]+1] - check_2[:,rosette["ru_ap_rmi"]["x"]:rosette["ru_ap_rmi"]["z"]+1])  )
>     print("check_drho_u.shape",check_drho_u.shape)
> 
>     # Constitution des sous pas de temps pour la resolution en Runge-Kutta (1/3, 5/12, 1/4)
>     # Le premier rk_step vaut 2. Le dernier rk_step vaut 2.
>     # Finalement, on peut s'en passer des sous_dt. Gardons-les desfois qu'il me les faudrai
>     sous_dt_0 = (check_0[0:,[rosette["t"]]] - check_2[0:,[rosette["t"]]]).flatten()
>     sous_dt_1 = (check_1[0:,[rosette["t"]]] - check_0[0:,[rosette["t"]]]).flatten()
>     sous_dt_2 = (check_2[0:,[rosette["t"]]] - check_1[0:,[rosette["t"]]]).flatten()
> 
> 
>     print("sous_dt_0[0:5]",sous_dt_0[0:5])
>     print("sous_dt_1[0:5]",sous_dt_1[0:5])
>     print("sous_dt_2[0:5]",sous_dt_2[0:5])
>     # temps = check_0[:,[rosette["t"]]]
> else :
>     print("# EULER EXPLICIT SIMLATION")
>     rk3 = False
>     check_0 = check[it_deb:it_fin,...]
>     temps = check_0[it_deb:it_fin,[rosette["t"]]]
> print("# Again the time : ")
> print("# t_deb = %s \n# t_fin = %s"%(temps[0], temps[-1]))
124a259,260
> rl = dtool.getParam(fichier_data, "rho_liquide")
> rv = dtool.getParam(fichier_data, "rho_vapeur")
129,130c265
< check = numpy.loadtxt(glob.glob(chemin_out)[-1])#[rosette["r_vel"]["x"]][it_deb:it_fin,1:]
< ########################################################################
---
> 
147a283
> # Declaration figures
152,156c288,302
< fig_t_rho, (ax_t_rho) = plt.subplots(1,1,figsize=(10,10)) # Effet du terme (rho^{n+1} - rho^{n}) * u^{n+1}
< fig_t_pres, (ax_t_pres) = plt.subplots(1,1,figsize=(10,10))
< fig_all, (ax_all) = plt.subplots(1,1,figsize=(10,10))
< fig_ru, (ax_ru) = plt.subplots(1,1,figsize=(10,10))
< fig_bilan, (ax_bilan) = plt.subplots(1,1,figsize=(10,10))
---
> fig_t_rho,  (ax_t_rho)  = plt.subplots(1,1,figsize=(10,10)) # Effet du terme (rho^{n+1} - rho^{n}) * u^{n+1}
> fig_t_pr_2, (ax_t_pr_2) = plt.subplots(1,1,figsize=(10,10)) # grad(p)
> fig_t_pr_3, (ax_t_pr_3) = plt.subplots(1,1,figsize=(10,10)) # 1/\rho grad(p)
> fig_t_pr_d, (ax_t_pr_d) = plt.subplots(1,1,figsize=(10,10))
> fig_all,    (ax_all)    = plt.subplots(1,1,figsize=(10,10))
> fig_ru,     (ax_ru)     = plt.subplots(1,1,figsize=(10,10))
> fig_bilan,  (ax_bilan)  = plt.subplots(1,1,figsize=(10,10))
> 
> fig_t_intf_ms, (ax_t_intf_ms) = plt.subplots(1,1,figsize=(10,10))
> fig_t_conv_ms, (ax_t_conv_ms) = plt.subplots(1,1,figsize=(10,10))
> fig_t_diff_ms, (ax_t_diff_ms) = plt.subplots(1,1,figsize=(10,10))
> fig_all_ms,    (ax_all_ms)    = plt.subplots(1,1,figsize=(10,10))
> 
> fig_t_intf.suptitle(r"$ dt \times \langle \frac{\mathcal{F}_i}{\mathcal{V} }\rangle$", fontsize=24)
> fig_t_intf_ms.suptitle(r"$ dt \times \langle \frac{\mathcal{F}_i}{\tilde{\rho} \mathcal{V} } \rangle$", fontsize=24)
158c304
< fig_t_intf.suptitle(r"$ dt \times \langle \frac{\mathcal{F_i}}{\tilde{\rho} \mathcal{V} }\rangle$", fontsize=24)
---
> # Titres figures
161c307,308
<     fig_t_conv.suptitle(r"$ dt \times \langle \tilde{\rho} \mathcal{S} \left[ -u_i uj \right] \rangle \frac{1}{\mathcal{V}}$", fontsize=24)
---
>     fig_t_conv.suptitle(r"$ dt \times \langle \tilde{\rho} \mathcal{S} \left[ -u_i u_j \right] \rangle \frac{1}{\mathcal{V}}$", fontsize=24)
>     fig_t_conv_ms.suptitle(r"$ dt \times \frac{ \langle \tilde{\rho} \mathcal{S} \left[ -u_i u_j \right] \rangle }{\tilde{\rho}} \frac{1}{\mathcal{V}}$", fontsize=24)
167a315
> fig_t_diff_ms.suptitle(r"$ dt \times \frac{ \langle \mathcal{S} \left[ \mu s_{ij} \right] + \mathcal{C} \rangle \frac{1}{\mathcal{V}} - \langle \mathcal{C} \rangle \frac{1}{\mathcal{V}} }{\tilde{\rho}}$", fontsize=24)
170c318,320
<     fig_t_pres.suptitle(r"$ dt \times \frac{1}{\rho} \nabla{p}$", fontsize=24)
---
>     fig_t_pr_2.suptitle(r"$ dt \times \nabla{p}$", fontsize=24)
>     fig_t_pr_3.suptitle(r"$ dt \times \frac{1}{\rho} \nabla{p}$", fontsize=24)
>     fig_t_pr_d.suptitle(r"$ \tilde{\rho}^* dt \times \nabla{p} _{1/2} - dt \times \frac{1}{\rho} \nabla{p}$", fontsize=24)
172c322,324
<     fig_t_pres.suptitle(r"$ dt \times \nabla{p}$", fontsize=24)
---
>     fig_t_pr_2.suptitle(r"$ dt \times \nabla{p}$", fontsize=24)
>     fig_t_pr_3.suptitle(r"$ dt \times \nabla{p}$, true", fontsize=24)
>     fig_t_pr_d.suptitle(r"$ dt \times \nabla{p}$, diff", fontsize=24)
175a328
> fig_all_ms.suptitle(r"Somme des termes, after m.s.", fontsize=24)
178,206d330
< # On recupere uniquement les instants 'utiles' (en RK3, un pas sur trois avance réellement le temps)
< # Dans IJK on a bien pris garde à faire un += quand il faut faire le += 
< # /!\ On prend garde a ne pas 'epurer' le terme en rho^{n+1} u^{n+1} - rho^{n} u^{n+1} en RK3
< # /!\ ==> En effet en schéma RK3 c'est la galère, au lieu d'avoir 
< #               terme_avancement_rho = rho^{n+1} u^{n+1} - rho^{n} u^{n+1}
< #         On va construire : 
< #               terme_avancement_rho = (rho^{n+1/3} u^{n+1/3} - rho^{n} u^{n+1/3}) + (rho^{n+2/3} u^{n+2/3} - rho^{n+1/3} u^{n+2/3}) + (rho^{n+1} u^{n+1} - rho^{n+2/3} u^{n+1})
< # Ce n'est pas tout a fait ce qu'on aurai voulu, mais qu'a cela ne tienne c'est la somme des evolutions pour chaque sous pas de temps. C'est pas mal non plus
< 
< if 2 in check[it_deb:it_fin,[rosette["rk"]]] :
<     print("# RK3 SIMULATION")
<     rk3 = True
<     indices_temps_rk3_0 = numpy.argwhere(check[it_deb:it_fin,[rosette["rk"]]]==0)[:,0]
<     indices_temps_rk3_1 = numpy.argwhere(check[it_deb:it_fin,[rosette["rk"]]]==1)[:,0]
<     indices_temps_rk3_2 = numpy.argwhere(check[it_deb:it_fin,[rosette["rk"]]]==2)[:,0]
<     
<     check_drho_u = (check[indices_temps_rk3_0,rosette["ru_av_rmi"]["x"]:rosette["ru_av_rmi"]["z"]+1] - check[indices_temps_rk3_0,rosette["ru_ap_rmi"]["x"]:rosette["ru_ap_rmi"]["z"]+1] + 
<                   check[indices_temps_rk3_1,rosette["ru_av_rmi"]["x"]:rosette["ru_av_rmi"]["z"]+1] - check[indices_temps_rk3_1,rosette["ru_ap_rmi"]["x"]:rosette["ru_ap_rmi"]["z"]+1] + 
<                   check[indices_temps_rk3_2,rosette["ru_av_rmi"]["x"]:rosette["ru_av_rmi"]["z"]+1] - check[indices_temps_rk3_2,rosette["ru_ap_rmi"]["x"]:rosette["ru_ap_rmi"]["z"]+1]  )
<     print("check_drho_u.shape",check_drho_u.shape)
<     check = check[indices_temps_rk3_0,...]
<     temps = check[:,[rosette["t"]]]
< else :
<     print("# EULER EXPLICIT SIMLATION")
<     rk3 = False
<     check = check[it_deb:it_fin,...]
<     temps = check[it_deb:it_fin,[rosette["t"]]]
< # print(check[trk3[0]:trk3[-1],[rosette["t_intf_bf_ms"][direction]]].shape)
< # print(check[it_deb:it_fin,[rosette["t_intf_bf_ms"][direction]]].shape)
209,210c333,334
< dt = check[1:,[rosette["t"]]] - check[:-1,[rosette["t"]]]
< dt = numpy.insert(dt,0,check[1,[rosette["t"]]])
---
> dt = check_0[1:,[rosette["t"]]] - check_0[:-1,[rosette["t"]]]
> dt = numpy.insert(dt,0,check_0[1,[rosette["t"]]])
211a336,343
> # On reforme le temps : les sous-pas de temps n'existent plus. Ils ont existé uniquement pour re-construire les termes totaux 
> if rk3:
>     it_deb_sub = vrai_it_deb # defini la ou on se debat avec les it_deb et tout, au debut
>     it_fin_sub = numpy.argwhere( numpy.abs(temps_2-t_fin == numpy.min(numpy.abs(temps_2-t_fin))))[0][0]
>     temps_plot = temps_2[it_deb_sub:it_fin_sub]
> else:
>     temps_plot = temps
> 
215,234c347,355
<     intf = check[:,[rosette["t_intf_bf_ms"][direction]]].flatten()
<     conv = check[:,[rosette["t_conv"][direction]]].flatten()
<     pres = check[:,[rosette["t_pres"][direction]]].flatten()
<     diff = check[:,[rosette["t_diff"][direction]]].flatten()
<     if rk3 :
<         drho_u = check_drho_u[1:,i] # (check[:,[rosette["ru_av_rmi"][direction]]] - check[:,[rosette["ru_ap_rmi"][direction]]]).flatten()
<         drho_u = numpy.insert(drho_u,0,0)    
<     else :
<         drho_u = (check[:,[rosette["ru_av_rmi"][direction]]] - check[:,[rosette["ru_ap_rmi"][direction]]]).flatten()
< 
<     # Construction du bilan, homogene a du
<     print(intf.shape)
<     print(conv.shape)
<     print(pres.shape)
<     print(diff.shape)
<     print(drho_u.shape)
<     print(dt.shape)
<     print(temps.shape,(conv*dt[:]).shape)
<     bilan = (intf+conv+pres+diff)*dt + drho_u
<     d_rhou = (check[1:,[rosette["ru_ap_rmi"][direction]]] - check[:-1,[rosette["ru_ap_rmi"][direction]]])  
---
>     intf = check_0[:,[rosette["t_intf_bf_ms"][direction]]].flatten()
>     conv = check_0[:,[rosette["t_conv"][direction]]].flatten()
>     pr_2 = check_0[:,[rosette["t_pr_2"][direction]]].flatten()
>     pr_3 = check_0[:,[rosette["t_pr_3"][direction]]].flatten()
>     # On s'attedns a avoir pr_d = 0 partout, tout le temps
>     pr_d = (1./rl + 1./rv)/2.*pr_2 - pr_3
>     diff = check_0[:,[rosette["t_diff"][direction]]].flatten()
>     drho_u = (check_0[:,[rosette["ru_av_rmi"][direction]]] - check_0[:,[rosette["ru_ap_rmi"][direction]]]).flatten()
>     d_rhou = (check_0[1:,[rosette["ru_ap_rmi"][direction]]] - check_0[:-1,[rosette["ru_ap_rmi"][direction]]])  
236,238c357,392
<     # terme interfaces
<     ax_t_intf_bis.plot(temps,intf*dt, color=color[direction]     ,linestyle=linestyle[3],label=direction+" interfaces bf. ms : I")
<     # ax_t_intf.plot(temps,check[it_deb:it_fin+1,[rosette["t_intf_af_ms"][direction]]], color=color[direction]     ,linestyle=linestyle[1],label=direction+" interfaces af. ms")
---
>     # Grandeurs apres etre passees au mass solver
>     intf_ms = check_0[:,[rosette["t_intf_af_ms"][direction]]].flatten()
>     conv_ms = check_0[:,[rosette["t_conv_mass_sol"][direction]]].flatten()
>     diff_ms = check_0[:,[rosette["t_diff_mass_sol"][direction]]].flatten()
> 
> 
> 
>     if rk3 :
>         intf_1, intf_2 = check_1[:,[rosette["t_intf_bf_ms"][direction]]].flatten(), check_2[:,[rosette["t_intf_bf_ms"][direction]]].flatten()
>         conv_1, conv_2 = check_1[:,[rosette["t_conv"][direction]]].flatten()      , check_2[:,[rosette["t_conv"][direction]]].flatten()      
>         pr_2_1, pr_2_2 = check_1[:,[rosette["t_pr_2"][direction]]].flatten()      , check_2[:,[rosette["t_pr_2"][direction]]].flatten()      
>         pr_3_1, pr_3_2 = check_1[:,[rosette["t_pr_3"][direction]]].flatten()      , check_2[:,[rosette["t_pr_3"][direction]]].flatten()      
>         pr_d_1, pr_d_2 = pr_2_1 - pr_2_1                                          , pr_2_2 - pr_3_2     
>         diff_1, diff_2 = check_1[:,[rosette["t_diff"][direction]]].flatten()      , check_2[:,[rosette["t_diff"][direction]]].flatten()      
>         # Grandeurs apres etre passees au mass solver
>         intf_ms_1, intf_ms_2 = check_1[:,[rosette["t_intf_af_ms"][direction]]].flatten()      , check_2[:,[rosette["t_intf_af_ms"][direction]]].flatten()      
>         conv_ms_1, conv_ms_2 = check_1[:,[rosette["t_conv_mass_sol"][direction]]].flatten()      , check_2[:,[rosette["t_conv_mass_sol"][direction]]].flatten()      
>         diff_ms_1, diff_ms_2 = check_1[:,[rosette["t_diff_mass_sol"][direction]]].flatten()      , check_2[:,[rosette["t_diff_mass_sol"][direction]]].flatten()      
> 
>         drho_u = check_drho_u[:,i] # (check[:,[rosette["ru_av_rmi"][direction]]] - check[:,[rosette["ru_ap_rmi"][direction]]]).flatten()
>         drho_u_0 =  (check_0[1:,[rosette["ru_ap_rmi"][direction]]] - check_0[:-1,[rosette["ru_ap_rmi"][direction]]]) 
>         # drho_u = numpy.insert(drho_u,0,0)    
>         print("drho_u.shape",drho_u.shape)
>         print("pressions",pr_3,pr_3_1,pr_3_2)
>         print("conv*sous_dt_0.shape",(conv*sous_dt_0).shape)
>         print("conv.shape,sous_dt_0.shape",conv.shape,sous_dt_0.shape)
>         intf = intf*alpha_0 + intf_1*alpha_1 + intf_2*alpha_2
>         conv = conv*alpha_0 + conv_1*alpha_1 + conv_2*alpha_2
>         pr_2 = pr_2*alpha_0 + pr_2_1*alpha_1 + pr_2_2*alpha_2
>         pr_3 = pr_3*alpha_0 + pr_3_1*alpha_1 + pr_3_2*alpha_2
>         pr_d = pr_d*alpha_0 + pr_d_1*alpha_1 + pr_d_2*alpha_2
>         diff = diff*alpha_0 + diff_1*alpha_1 + diff_2*alpha_2
>         # Grandeurs apres etre passe au mass solver
>         intf_ms = intf_ms*alpha_0 + intf_ms_1*alpha_1 + intf_ms_2*alpha_2
>         conv_ms = conv_ms*alpha_0 + conv_ms_1*alpha_1 + conv_ms_2*alpha_2
>         diff_ms = diff_ms*alpha_0 + diff_ms_1*alpha_1 + diff_ms_2*alpha_2
240,241c394,414
<     # terme convection
<     ax_t_conv.plot(temps,conv*dt, color=color[direction]     ,linestyle=linestyle[0],label=direction+" convection")
---
>         pr_d_dt = pr_d*dt
>     # else:
>     intf_dt = intf*dt
>     conv_dt = conv*dt
>     pr_2_dt = pr_2*dt
>     pr_3_dt = pr_3*dt
>     diff_dt = diff*dt
>     # Grandeurs apres etre passe au mass solver
>     intf_ms_dt = intf_ms*dt
>     conv_ms_dt = conv_ms*dt
>     diff_ms_dt = diff_ms*dt
>     # print("intf_ms_dt",intf_ms_dt)
>     ###################################################
>     # Construction du bilan, homogene a rho du pou rles variables "normales" et homognee a du pour les variables en _ms
>     # Etre exactement fidele au code dans la reconstruction demande trop de manipulations
>     # Pour le bilan on prend donc la grandeur grad(p)
>     # Si on veut etre tres fidele a IJK, il faut calculer t_conv, t_diff, t_inf APRES QU'IL SOIENT PASSÉS DANS LE MASS SOLVER
>     # pour ce faire, il faudrai passer {t_conv} au mass solver, puis {t_diff + t_conv} au mass solveur. On en deduit {t_diff} apres mass solver
>     # et ainsi de suite pour les autres termes qui sont ajoutes AVANT la contribution de la gravite
>     # ATTENTION les interfaces sont ajoutees directement a la velocity.
>     # Dans ce cas, il va falloir creer de nouveaux champs...
242a416,426
>     # bilan = (intf+conv+pr_2+diff)*dt + drho_u
>     bilan = intf_dt+conv_dt+pr_2_dt+diff_dt + drho_u                          # @ d(\rho u)/dt
>     bilan_ms = intf_ms_dt+conv_ms_dt+pr_3_dt+diff_ms_dt + drho_u*(2./(rl+rv))  # @ du/dt   (apres mass solver)
>     # terme interfaces
>     ax_t_intf_bis.plot(temps_plot,intf_dt, color=color[direction]     ,linestyle=linestyle[3],label=direction+" interfaces bf. ms : I")
>     ax_t_intf_ms.plot(temps_plot,intf_ms_dt, color=color[direction]     ,linestyle=linestyle[1],label=direction+" interfaces af. ms")
> 
>     # terme convection
>     ax_t_conv.plot(temps_plot,conv_dt, color=color[direction]     ,linestyle=linestyle[0],label=direction+" convection")
>     ax_t_conv_ms.plot(temps_plot,conv_ms_dt, color=color[direction]     ,linestyle=linestyle[0],label=direction+" conv. after m.s.")
> 
244,245c428,431
<     ax_t_pres.plot(temps,pres*dt, color=color[direction]     ,linestyle=linestyle[0],label=direction+" pression")
<     
---
>     ax_t_pr_2.plot(temps_plot,pr_2_dt, color=color[direction]     ,linestyle=linestyle[0],label=direction+" pression")
>     ax_t_pr_3.plot(temps_plot,pr_3_dt, color=color[direction]     ,linestyle=linestyle[0],label=direction+" pression")
>     ax_t_pr_d.plot(temps_plot,pr_d_dt, color=color[direction]     ,linestyle=linestyle[0],label=direction+" pression")
> 
247c433,434
<     ax_t_diff.plot(temps,diff*dt, color=color[direction]     ,linestyle=linestyle[0],label=direction+" diffusion")
---
>     ax_t_diff.plot(temps_plot,diff_dt, color=color[direction]     ,linestyle=linestyle[0],label=direction+" diffusion")
>     ax_t_diff_ms.plot(temps_plot,diff_ms_dt, color=color[direction]     ,linestyle=linestyle[0],label=direction+" diff. after m.s.")
250,251c437,438
<     ax_t_rho.plot(temps,drho_u, color=color[direction]     ,linestyle=linestyle[0],label=direction+r" $ (d_n \rho) \times u^{n+1}$")
<     
---
>     ax_t_rho.plot(temps_plot,drho_u, color=color[direction]     ,linestyle=linestyle[0],label=direction+r" $ (d_n \rho) \times u^{n+1}$")
> 
254,256c441,445
<     ax_all.plot(temps,bilan, color=color[direction]     ,linestyle="solid",label=direction+" sum")
<     ax_all.plot(temps, d_rhou, color=color[direction]     ,linestyle="solid",label=direction+r"$\partial (\rho u) $")
<     
---
>     ax_all.plot(temps_plot,bilan, color=color[direction]     ,linestyle="solid",label=direction+r" $(\mathcal{I} + \mathcal{C} + \mathcal{P} + \mathcal{D})\times dt + (\partial \rho) u$")
>     ax_all_ms.plot(temps_plot,bilan_ms, color=color[direction]     ,linestyle="solid",label=direction+r" $(\mathcal{I} + \mathcal{C} + \mathcal{P} + \mathcal{D})\times dt + (\partial \rho) u$, after m.s.")
>     print("temps_plot.shape, d_rhou.shape",temps_plot.shape, d_rhou.shape)
>     ax_all.plot(temps_plot, d_rhou, color=color[direction]     ,linestyle="dashed",label=direction+r"$\partial (\rho u) $")
> 
258,263c447,453
<     ax_ru.plot(temps, conv*dt ,color=color[direction],linestyle=linestyle[0],label=direction+" convection")
<     ax_ru.plot(temps, intf*dt ,color=color[direction],linestyle=linestyle[1],label=direction+" interfaces")
<     ax_ru.plot(temps, pres*dt ,color=color[direction],linestyle=linestyle[2],label=direction+" pression") 
<     ax_ru.plot(temps, diff*dt ,color=color[direction],linestyle=linestyle[3],label=direction+" diffusion") 
<     ax_ru.scatter(temps, drho_u ,color=color[direction],s=5,label=direction+" transport chi") 
<     # ax_ru.scatter(temps, d_rhou ,color=color[direction],s = 7,label=direction+r"$ \partial_t (\rho u)$") 
---
>     ax_ru.plot(temps_plot, conv_dt ,color=color[direction],linestyle=linestyle[0],label=direction+" convection")
>     ax_ru.plot(temps_plot, intf_dt ,color=color[direction],linestyle=linestyle[1],label=direction+" interfaces")
>     ax_ru.plot(temps_plot, pr_2_dt ,color=color[direction],linestyle=linestyle[2],label=direction+" pression") 
>     ax_ru.plot(temps_plot, pr_3_dt ,color=color[direction],linestyle=linestyle[2],alpha=0.5,linewidth=3,label=direction+" pression") 
>     ax_ru.plot(temps_plot, diff_dt ,color=color[direction],linestyle=linestyle[3],label=direction+" diffusion") 
>     ax_ru.scatter(temps_plot, drho_u ,color=color[direction],s=5,label=direction+" transport chi") 
>     # ax_ru.scatter(temps_plot, d_rhou ,color=color[direction],s = 7,label=direction+r"$ \partial_t (\rho u)$") 
266a457
> ax_t_intf_ms.legend();ax_t_intf_ms.grid(True,'minor')
267a459
> ax_t_conv_ms.legend();ax_t_conv_ms.grid(True,'minor')
268a461
> ax_t_diff_ms.legend();ax_t_diff_ms.grid(True,'minor')
269a463
> ax_all_ms.legend();ax_all_ms.grid(True,'minor')
274a469
> ax_t_intf_ms.set_xlabel("temps (s)"    ,fontsize=22)
275a471
> ax_t_conv_ms.set_xlabel("temps (s)"    ,fontsize=22)
276a473
> ax_t_diff_ms.set_xlabel("temps (s)"     ,fontsize=22)
278c475,478
< ax_t_pres.set_xlabel("temps (s)"      ,fontsize=22)
---
> ax_all_ms.set_xlabel("temps (s)"     ,fontsize=22)
> ax_t_pr_2.set_xlabel("temps (s)"      ,fontsize=22)
> ax_t_pr_3.set_xlabel("temps (s)"      ,fontsize=22)
> ax_t_pr_d.set_xlabel("temps (s)"      ,fontsize=22)
282a483
> ax_t_intf_ms.set_ylabel(r"$\frac{1}{\tilde{\rho}} \int \sigma^{n} \kappa^{n} n $ "      , fontsize=22)
283a485
> ax_t_conv_ms.set_ylabel(r"$ \frac{1}{\tilde{\rho}} u^{*n} \nabla u^{*n}$ "    , fontsize=22)
285c487,490
< ax_t_pres.set_ylabel(r"$\frac{1}{\rho} \nabla p$ ", fontsize=22)
---
> ax_t_diff_ms.set_ylabel(r"$\frac{1}{\tilde{\rho}} 2 \nu \nabla s_{ij}$ ", fontsize=22)
> ax_t_pr_2.set_ylabel(r"$\frac{1}{\rho} \nabla p$ ", fontsize=22)
> ax_t_pr_3.set_ylabel(r"$\frac{1}{\rho} \nabla p$ true ", fontsize=22)
> ax_t_pr_d.set_ylabel(r"$\frac{1}{\rho} \nabla p$ diff ", fontsize=22)
286a492
> ax_all.set_ylabel(r"$ u$, bilan"                             , fontsize=22)
288a495
> # plt.show()
290a498
> fig_t_intf_ms.savefig(nom_figure+"_t_intf_ms"+directions+".png")
291a500
> fig_t_conv_ms.savefig(nom_figure+"_t_conv_ms"+directions+".png")
292a502
> fig_t_diff_ms.savefig(nom_figure+"_t_diff_ms"+directions+".png")
294c504,506
< fig_t_pres.savefig(nom_figure+"_t_pres_"+directions+".png")
---
> fig_t_pr_2.savefig(nom_figure+"_t_pr_2_"+directions+".png")
> fig_t_pr_3.savefig(nom_figure+"_t_pr_3_"+directions+".png")
> fig_t_pr_d.savefig(nom_figure+"_t_pr_d_"+directions+".png")
295a508
> fig_all_ms.savefig(nom_figure+"_all_ms"+directions+".png")

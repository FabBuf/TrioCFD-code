//TRUST_NO_INDENT
/****************************************************************************
* Copyright (c) 2019, CEA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
*****************************************************************************/
/////////////////////////////////////////////////////////////////////////////
//
// File      : simd_tools_port_Vc.h
// Directory : $IJK_ROOT/IJK_Kernel/src/IJK/solveur_mg
//
/////////////////////////////////////////////////////////////////////////////
//
// WARNING: DO NOT EDIT THIS FILE! Only edit the template file simd_tools_Vc.h.P
//

#ifndef SIMD_TOOLS_PORT_VC_H
#define SIMD_TOOLS_PORT_VC_H

#include <assert.h>
#include <stdint.h>
#include <Vc/Vc>

/*! @brief returns the size in bytes of SIMD vectors on the current architecture
 *
 */
inline static constexpr int simd_getalign()
{
  return Vc_1::MemoryAlignment;
}

/*! @brief allocates a memory bloc of given size with proper alignment for SIMD.
 *
 */
template<typename T>
inline T* simd_malloc (std::size_t size)
{
	return Vc::malloc<T, Vc::AlignOnCacheline>(size);
}

/*! @brief frees a memory bloc previously allocated with simd_malloc()
 *
 */
inline void simd_free(void* ptr)
{  
   Vc::free(ptr);
}

// uintptr_t should be defined in stdint.h
//  (this type is the result of pointer operations like ptr1-ptr2)
typedef uintptr_t uintptr_type;
/*! @brief returns 1 if pointer is aligned on size bytes, 0 otherwise Warn: size must be a power of 2.
 *
 */
inline int aligned(const void *ptr, int size)
{
  return ((uintptr_type)ptr & (uintptr_type)(size-1)) == 0;
}

#define _SimdAligned_ __attribute__ (( aligned(simd_getalign()) ))


// Implementation for single precision type

/*! @brief This class provides a generic access to simd operations on x86, x86 AMD and ARM architectures.
 *
 * Functionalities provided by the class are :
 *   - load vector size aligned data from memory (SimdGet)
 *   - getting x[i-1] and x[i+1] for finite difference algorithms
 *     (SimdGetAtLeft, SimdGetAtRight, etc)
 *   - arithmetic operations (+ - * /)
 *   - conditional affectation (SimdSelect)
 *  See simd_malloc() and simd_free() to allocate aligned blocs of memory.
 *
 */
class Simd_float
{
public:
  typedef float value_type;
  
  Simd_float() {};
  // Size of the vector
  static int size() {
  	return Vc::float_v::Size ;
  }

  void operator+=(Simd_float a) {
    data_ += a.data_;
  }
  void operator*=(Simd_float a) {
    data_ *= a.data_;
  }
  void operator-=(Simd_float a) {
    data_ -= a.data_;
  }
 
  Vc::float_v data_;
  // Commodity default constructor (provides implicit conversion)
  Simd_float(Vc::float_v x) : data_(x) {};
  Simd_float(float x) : data_(x) {};

};



/*! @brief Returns the vector found at address data.
 *
 * data must be aligned for the architecture (see simd_malloc())
 *
 */
inline Simd_float SimdGet(const float *data)
{
    Vc::float_v v(data, Vc::Aligned);	
	return v;
}

/*! @brief Stores vector x at address data.
 *
 * data must be aligned for the architecture (see simd_malloc())
 *
 */
inline void SimdPut(float *data, Simd_float x)
{
	x.data_.store(data, Vc::Aligned);
}

/*! @brief Returns the vector x starting at adress data+1 data must be aligned for the architecture (see simd_malloc())
 *
 */
inline Simd_float SimdGetAtRight(const float *data)
{
  Vc::float_v first_vector(data, Vc::Aligned);
  Vc::float_v second_vector(data+Vc::float_v::Size, Vc::Aligned);
  
  //first_vector and second_vector are concatenated and then shifted by 1 to the left  
  Vc::float_v data_plus_1 = first_vector.shifted(1, second_vector); 
  return data_plus_1;
}

/*! @brief Returns the vector x starting at adress data-1 data must be aligned for the architecture (see simd_malloc())
 *
 */
inline Simd_float SimdGetAtLeft(const float *data)
{
  Vc::float_v first_vector(data - Vc::float_v::Size, Vc::Aligned);
  Vc::float_v second_vector(data, Vc::Aligned);
  
  //first_vector and second_vector are concatenated and then shifted by size_of_vector-1 to the left  
  Vc::float_v data_minus_1 = first_vector.shifted(Vc::float_v::Size - 1, second_vector); 
  return data_minus_1;
  
}

/*! @brief Returns the vector left and center starting at adress data-1 and data data must be aligned for the architecture (see simd_malloc())
 *
 */
inline void SimdGetLeftCenter(const float *data, Simd_float &left, Simd_float &center)
{

  Vc::float_v first_vector(data - Vc::float_v::Size, Vc::Aligned);
  Vc::float_v second_vector(data, Vc::Aligned);
  
  //first_vector and second_vector are concatenated and then shifted by size_of_vector-1 to the left  
  Vc::float_v data_minus_1 = first_vector.shifted(Vc::float_v::Size - 1, second_vector); 
  
  left =  data_minus_1;
  center =  second_vector;
}

/*! @brief Returns the vector center and right starting at adress data and data+1 data must be aligned for the architecture (see simd_malloc())
 *
 */
inline void SimdGetCenterRight(const float *data, 
				   Simd_float &center,
				   Simd_float &right)
{
  Vc::float_v first_vector(data, Vc::Aligned);
  Vc::float_v second_vector(data+Vc::float_v::Size, Vc::Aligned);
  
  //first_vector and second_vector are concatenated and then shifted by 1 to the left  
  Vc::float_v data_plus_1 = first_vector.shifted(1, second_vector); 
  center = first_vector;
  right = data_plus_1;


}

/*! @brief Returns the vectors left, center and right starting at adress data-1, data and data+1 data must be aligned for the architecture (see simd_malloc())
 *
 */
inline void SimdGetLeftCenterRight(const float *data, 
				   Simd_float &left,
				   Simd_float &center,
				   Simd_float &right)
{

  Vc::float_v first_vector(data-Vc::float_v::Size, Vc::Aligned);
  Vc::float_v second_vector(data, Vc::Aligned);
  Vc::float_v third_vector(data+Vc::float_v::Size, Vc::Aligned);
  
  //shifting second_vector by 1 to the left and padding in elements of third_vector
  Vc::float_v data_plus_1 = second_vector.shifted(1, third_vector);   
  //shifting first_vector by size_of_vector-1 to the left and padding in elements of second_vector
  Vc::float_v data_minus_1 = first_vector.shifted(Vc::float_v::Size - 1, second_vector); 
  
  
  left =  data_minus_1;
  center =  second_vector;
  right = data_plus_1;


}

/*! @brief Returns the vectors leftleft, left, center and right starting at adress data-2, data-1, data and data+1 data must be aligned for the architecture (see simd_malloc())
 *
 */
inline void SimdGetLeftleftLeftCenterRight(const float *data, 
					   Simd_float &leftleft,
					   Simd_float &left,
					   Simd_float &center,
					   Simd_float &right)
{
  Vc::float_v first_vector(data-Vc::float_v::Size, Vc::Aligned);
  Vc::float_v second_vector(data, Vc::Aligned);
  Vc::float_v third_vector(data+Vc::float_v::Size, Vc::Aligned);
  
  //shifting second_vector by 1 to the left and padding in elements of third_vector
  Vc::float_v data_plus_1 = second_vector.shifted(1, third_vector);   
  //shifting first_vector by size_of_vector-1 to the left and padding in elements of second_vector
  Vc::float_v data_minus_1 = first_vector.shifted(Vc::float_v::Size - 1, second_vector);
  //shifting first_vector by size_of_vector-2 to the left and padding in elements of second_vector
  Vc::float_v data_minus_2 = first_vector.shifted(Vc::float_v::Size - 2, second_vector); 
  
  
  leftleft = data_minus_2;
  left =  data_minus_1;
  center =  second_vector;
  right = data_plus_1;


}


#if 0
/*! @brief this class optimizes the fetching of data at left and at right of an increasing pointer.
 *
 *   Example with float *A for arrays of size 4:
 *   SimdLeftCenterRightGetter obj(A); // prepares to fetch the values around A
 *   obj.fetch(A); // fetches A[-1]..A[2] in left, A[0]..A[3] in center and A[1]..A[4] in right
 *   A += 4;
 *   obj.fetch(A); // fetches values around A[4]..A[8]
 *
 */
class SimdLeftCenterRightGetter
{
  SimdLeftCenterRightGetter(const float *data);
  void shift_and_get(const float *data) {
    data_left_ = 
  }
  _VT_ left();
  _VT_ center();
  _VT_ right();
 protected:
  _m128 data_left_; // aligned value at left
  _m128 data_center1_; // aligned value at center
  _m128 data_center2_;
  _m128 data_right_;
};
#endif

/*! @brief returns a+b
 *
 */
inline Simd_float operator+(Simd_float a, Simd_float b)
{
	return a.data_ + b.data_;
}

/*! @brief returns a-b
 *
 */
inline Simd_float operator-(Simd_float a, Simd_float b)
{
  return a.data_ - b.data_;
}

/*! @brief returns a*b
 *
 */
inline Simd_float operator*(Simd_float a, Simd_float b)
{
  return a.data_ * b.data_;
}


inline Simd_float Simd_absolute_value(Simd_float a)
{
	return Vc::abs(a.data_);
}

/*! @brief This function performs the following operation on the vectors for (i=0; i<size())
 *
 *    if (x1[i] < x2[i])
 *      result[i] = value_if_x1_lower_than_x2[i]
 *    else
 *      result[i] = value_otherwise[i]
 *
 */
inline Simd_float SimdSelect(Simd_float x1,
			       Simd_float x2,
			       Simd_float value_if_x1_lower_than_x2,
			       Simd_float value_otherwise)
{

  Vc::float_v compare = x1.data_ - x2.data_; //comparing x1 and x2
 
  Vc::float_v resu;
  //using compare as a maks to determine resu values
  resu(compare < 0) = value_if_x1_lower_than_x2.data_;
  resu(compare >= 0) = value_otherwise.data_;

  return resu;
}

// Returns a vector built with min(a[i],b[i]) (element wise)
inline Simd_float SimdMin(const Simd_float & a, const Simd_float  & b)
{
  return Vc::min(a.data_, b.data_);
}

// Returns a vector built with max(a[i],b[i]) (element wise)
inline Simd_float SimdMax(const Simd_float & a, const Simd_float  & b)
{
  return Vc::max(a.data_, b.data_);
}

// Returns approximate result of a/b
inline Simd_float SimdDivideMed(const Simd_float & a, const Simd_float & b)
{

  Vc::float_v x = Vc::reciprocal(b.data_); // x = approximation de 1/b
  Vc::float_v y = a.data_ * x; // y = a * x
  // resu = (a.data_ - b.data_ * y) * x + y
  Vc::float_v resu = (a.data_ - b.data_ * y) * x + y;
  return resu;


}

// Returns approximate result of 1/b
inline Simd_float SimdReciprocalMed(const Simd_float & b)
{
  Vc::float_v x = Vc::reciprocal(b.data_); // x = approximation de 1/b
  // resu = (2 - b * x) * x
  Vc::float_v two(2.);
  Vc::float_v resu = (two - b.data_ * x) * x;
  return resu;
}

// Implementation for double precision type

/*! @brief This class provides a generic access to simd operations on x86, x86 AMD and ARM architectures.
 *
 * Functionalities provided by the class are :
 *   - load vector size aligned data from memory (SimdGet)
 *   - getting x[i-1] and x[i+1] for finite difference algorithms
 *     (SimdGetAtLeft, SimdGetAtRight, etc)
 *   - arithmetic operations (+ - * /)
 *   - conditional affectation (SimdSelect)
 *  See simd_malloc() and simd_free() to allocate aligned blocs of memory.
 *
 */
class Simd_double
{
public:
  typedef double value_type;
  
  Simd_double() {};
  // Size of the vector
  static int size() {
  	return Vc::double_v::Size ;
  }

  void operator+=(Simd_double a) {
    data_ += a.data_;
  }
  void operator*=(Simd_double a) {
    data_ *= a.data_;
  }
  void operator-=(Simd_double a) {
    data_ -= a.data_;
  }
 
  Vc::double_v data_;
  // Commodity default constructor (provides implicit conversion)
  Simd_double(Vc::double_v x) : data_(x) {};
  Simd_double(double x) : data_(x) {};

};



/*! @brief Returns the vector found at address data.
 *
 * data must be aligned for the architecture (see simd_malloc())
 *
 */
inline Simd_double SimdGet(const double *data)
{
    Vc::double_v v(data, Vc::Aligned);	
	return v;
}

/*! @brief Stores vector x at address data.
 *
 * data must be aligned for the architecture (see simd_malloc())
 *
 */
inline void SimdPut(double *data, Simd_double x)
{
	x.data_.store(data, Vc::Aligned);
}

/*! @brief Returns the vector x starting at adress data+1 data must be aligned for the architecture (see simd_malloc())
 *
 */
inline Simd_double SimdGetAtRight(const double *data)
{
  Vc::double_v first_vector(data, Vc::Aligned);
  Vc::double_v second_vector(data+Vc::double_v::Size, Vc::Aligned);
  
  //first_vector and second_vector are concatenated and then shifted by 1 to the left  
  Vc::double_v data_plus_1 = first_vector.shifted(1, second_vector); 
  return data_plus_1;
}

/*! @brief Returns the vector x starting at adress data-1 data must be aligned for the architecture (see simd_malloc())
 *
 */
inline Simd_double SimdGetAtLeft(const double *data)
{
  Vc::double_v first_vector(data - Vc::double_v::Size, Vc::Aligned);
  Vc::double_v second_vector(data, Vc::Aligned);
  
  //first_vector and second_vector are concatenated and then shifted by size_of_vector-1 to the left  
  Vc::double_v data_minus_1 = first_vector.shifted(Vc::double_v::Size - 1, second_vector); 
  return data_minus_1;
  
}

/*! @brief Returns the vector left and center starting at adress data-1 and data data must be aligned for the architecture (see simd_malloc())
 *
 */
inline void SimdGetLeftCenter(const double *data, Simd_double &left, Simd_double &center)
{

  Vc::double_v first_vector(data - Vc::double_v::Size, Vc::Aligned);
  Vc::double_v second_vector(data, Vc::Aligned);
  
  //first_vector and second_vector are concatenated and then shifted by size_of_vector-1 to the left  
  Vc::double_v data_minus_1 = first_vector.shifted(Vc::double_v::Size - 1, second_vector); 
  
  left =  data_minus_1;
  center =  second_vector;
}

/*! @brief Returns the vector center and right starting at adress data and data+1 data must be aligned for the architecture (see simd_malloc())
 *
 */
inline void SimdGetCenterRight(const double *data, 
				   Simd_double &center,
				   Simd_double &right)
{
  Vc::double_v first_vector(data, Vc::Aligned);
  Vc::double_v second_vector(data+Vc::double_v::Size, Vc::Aligned);
  
  //first_vector and second_vector are concatenated and then shifted by 1 to the left  
  Vc::double_v data_plus_1 = first_vector.shifted(1, second_vector); 
  center = first_vector;
  right = data_plus_1;


}

/*! @brief Returns the vectors left, center and right starting at adress data-1, data and data+1 data must be aligned for the architecture (see simd_malloc())
 *
 */
inline void SimdGetLeftCenterRight(const double *data, 
				   Simd_double &left,
				   Simd_double &center,
				   Simd_double &right)
{

  Vc::double_v first_vector(data-Vc::double_v::Size, Vc::Aligned);
  Vc::double_v second_vector(data, Vc::Aligned);
  Vc::double_v third_vector(data+Vc::double_v::Size, Vc::Aligned);
  
  //shifting second_vector by 1 to the left and padding in elements of third_vector
  Vc::double_v data_plus_1 = second_vector.shifted(1, third_vector);   
  //shifting first_vector by size_of_vector-1 to the left and padding in elements of second_vector
  Vc::double_v data_minus_1 = first_vector.shifted(Vc::double_v::Size - 1, second_vector); 
  
  
  left =  data_minus_1;
  center =  second_vector;
  right = data_plus_1;


}

/*! @brief Returns the vectors leftleft, left, center and right starting at adress data-2, data-1, data and data+1 data must be aligned for the architecture (see simd_malloc())
 *
 */
inline void SimdGetLeftleftLeftCenterRight(const double *data, 
					   Simd_double &leftleft,
					   Simd_double &left,
					   Simd_double &center,
					   Simd_double &right)
{
  Vc::double_v first_vector(data-Vc::double_v::Size, Vc::Aligned);
  Vc::double_v second_vector(data, Vc::Aligned);
  Vc::double_v third_vector(data+Vc::double_v::Size, Vc::Aligned);
  
  //shifting second_vector by 1 to the left and padding in elements of third_vector
  Vc::double_v data_plus_1 = second_vector.shifted(1, third_vector);   
  //shifting first_vector by size_of_vector-1 to the left and padding in elements of second_vector
  Vc::double_v data_minus_1 = first_vector.shifted(Vc::double_v::Size - 1, second_vector);
  //shifting first_vector by size_of_vector-2 to the left and padding in elements of second_vector
  Vc::double_v data_minus_2 = first_vector.shifted(Vc::double_v::Size - 2, second_vector); 
  
  
  leftleft = data_minus_2;
  left =  data_minus_1;
  center =  second_vector;
  right = data_plus_1;


}


#if 0
/*! @brief this class optimizes the fetching of data at left and at right of an increasing pointer.
 *
 *   Example with float *A for arrays of size 4:
 *   SimdLeftCenterRightGetter obj(A); // prepares to fetch the values around A
 *   obj.fetch(A); // fetches A[-1]..A[2] in left, A[0]..A[3] in center and A[1]..A[4] in right
 *   A += 4;
 *   obj.fetch(A); // fetches values around A[4]..A[8]
 *
 */
class SimdLeftCenterRightGetter
{
  SimdLeftCenterRightGetter(const double *data);
  void shift_and_get(const double *data) {
    data_left_ = 
  }
  _VT_ left();
  _VT_ center();
  _VT_ right();
 protected:
  _m128 data_left_; // aligned value at left
  _m128 data_center1_; // aligned value at center
  _m128 data_center2_;
  _m128 data_right_;
};
#endif

/*! @brief returns a+b
 *
 */
inline Simd_double operator+(Simd_double a, Simd_double b)
{
	return a.data_ + b.data_;
}

/*! @brief returns a-b
 *
 */
inline Simd_double operator-(Simd_double a, Simd_double b)
{
  return a.data_ - b.data_;
}

/*! @brief returns a*b
 *
 */
inline Simd_double operator*(Simd_double a, Simd_double b)
{
  return a.data_ * b.data_;
}


inline Simd_double Simd_absolute_value(Simd_double a)
{
	return Vc::abs(a.data_);
}

/*! @brief This function performs the following operation on the vectors for (i=0; i<size())
 *
 *    if (x1[i] < x2[i])
 *      result[i] = value_if_x1_lower_than_x2[i]
 *    else
 *      result[i] = value_otherwise[i]
 *
 */
inline Simd_double SimdSelect(Simd_double x1,
			       Simd_double x2,
			       Simd_double value_if_x1_lower_than_x2,
			       Simd_double value_otherwise)
{

  Vc::double_v compare = x1.data_ - x2.data_; //comparing x1 and x2
 
  Vc::double_v resu;
  //using compare as a maks to determine resu values
  resu(compare < 0) = value_if_x1_lower_than_x2.data_;
  resu(compare >= 0) = value_otherwise.data_;

  return resu;
}

// Returns a vector built with min(a[i],b[i]) (element wise)
inline Simd_double SimdMin(const Simd_double & a, const Simd_double  & b)
{
  return Vc::min(a.data_, b.data_);
}

// Returns a vector built with max(a[i],b[i]) (element wise)
inline Simd_double SimdMax(const Simd_double & a, const Simd_double  & b)
{
  return Vc::max(a.data_, b.data_);
}

// Returns approximate result of a/b
inline Simd_double SimdDivideMed(const Simd_double & a, const Simd_double & b)
{

  Vc::double_v x = Vc::reciprocal(b.data_); // x = approximation de 1/b
  Vc::double_v y = a.data_ * x; // y = a * x
  // resu = (a.data_ - b.data_ * y) * x + y
  Vc::double_v resu = (a.data_ - b.data_ * y) * x + y;
  return resu;


}

// Returns approximate result of 1/b
inline Simd_double SimdReciprocalMed(const Simd_double & b)
{
  Vc::double_v x = Vc::reciprocal(b.data_); // x = approximation de 1/b
  // resu = (2 - b * x) * x
  Vc::double_v two(2.);
  Vc::double_v resu = (two - b.data_ * x) * x;
  return resu;
}



class Simd_int
{
public:
  typedef int value_type;
 
  Simd_int() {};
  
  //on souhaite que la taille d'un vecteur d'entiers soit la meme que celle d'un vecteur de flottants
  static int size() {
    return Vc::float_v::Size;
  }

  void operator|=(Simd_int a) {
  
    //on parcourt chaque vecteur d'entiers qui composent data_
    for(size_t j = 0; j < data_.vectorsCount(); j++)
	{
	  data_.vector(j) =  data_.vector(j) | a.data_.vector(j);
	}
  
  }


  // dans certains cas, un vecteur de flottants n'a pas la meme taille qu'un vecteur d'entiers 
  // on aimerait que ce soit le cas pour pouvoir facilement les comparer 
  // on utilise donc la structure de donnees Vc:::Memory qui est compose d'un certain nombre de vecteurs d'entiers
  // mais dont la taille totale est celle d'un vecteur de flottants
  // par exemple, si la taille d'un vecteur de flottants est 8 et la taille d'un vecteur d'entiers est 4
  // data_ sera compose de 2 vecteurs d'entiers de taille 4 
  Vc::Memory<Vc::int_v,  Vc::float_v::Size> data_;

  // Commodity default constructor (provides implicit conversion)
  Simd_int(Vc::Memory<Vc::int_v,  Vc::float_v::Size> x) : data_(x) {};
  Simd_int(int x)
  {
  	//on parcourt chaque vecteur d'entiers qui composent data_, et on les initialise a x
    for(size_t j = 0; j < data_.vectorsCount(); j++)
	{
	  Vc::int_v value(x);
	  data_.vector(j) = value;
	}
 
  };
};

/*! @brief Returns the vector found at address data.
 *
 * data must be aligned for the architecture (see simd_malloc())
 *
 */
inline Simd_int SimdGet(const int *data)
{
	Vc::Memory<Vc::int_v,  Vc::float_v::Size> res;
	
	//on parcourt chaque vecteur d'entiers qui composent res
    //et on charge les valeurs de data correspondantes	
    for(size_t j = 0; j < res.vectorsCount(); j++)
	{
	  Vc::int_v res_vector_i;
	  res_vector_i.load(&data[j * Vc::int_v::Size], Vc::Aligned);
	  res.vector(j) = res_vector_i;
	}
	
	return res;

}

/*! @brief Stores vector x at address data.
 *
 * data must be aligned for the architecture (see simd_malloc())
 *
 */
inline void SimdPut(int *data, Simd_int x)
{
	//on parcourt chaque vecteur d'entiers qui composent x
    //et on stocke les valeurs qu'elles contiennt dans data
    for(size_t j = 0; j < x.data_.vectorsCount(); j++)
	{
	  Vc::int_v x_vector_i = x.data_.vector(j);
	  x_vector_i.store(&data[j * Vc::int_v::Size], Vc::Aligned);
	}

}
#if 0
// Returns 0 if x1!=x2 and value_if_equal if x1==x2
inline Simd_int SimdTestEqual(Simd_float x1, Simd_float x2, Simd_int value_if_equal)
{
  return _mm_and_si128(_mm_castps_si128(_mm_cmpeq_ps(x1.data_, x2.data_)), value_if_equal.data_);
}

inline Simd_int SimdTestEqual(Simd_float x1, Simd_float x2, 
			      Simd_int value_if_equal, Simd_int value_if_not_equal)
{
  __m128i compare = _mm_castps_si128(_mm_cmpeq_ps(x1.data_, x2.data_));
  return _mm_or_si128(_mm_and_si128(compare, value_if_equal.data_),
		      _mm_andnot_si128(compare, value_if_not_equal.data_));
}
#endif

inline Simd_int SimdSelect(Simd_float x1,
			   Simd_float x2,
			   Simd_int value_if_x1_lower_than_x2,
			   Simd_int value_otherwise)
{

  //on compare x1 et x2 
  Vc::Mask<float> mask = (x1.data_ < x2.data_);
  
  // on veut que le masque ait la meme structure que le membre data_ de Simd_int
  // par exemple si data_ de Simd_int contient 2 vecteurs d'entiers,
  // le masque doit aussi etre compose de 2 vecteurs d'entiers
  Vc::Memory<Vc::Mask<int>, Vc::Mask<float>::Size> mask_int;
  for (size_t i= 0; i < Vc::Mask<float>::Size; ++i) { mask_int[i] = mask[i]; }

  Vc::Memory<Vc::int_v,  Vc::float_v::Size> res;
  
  //on parcourt chaque vecteur d'entiers qui compose res
  //et on applique la selection sur chacun d'entre eux 
  for (size_t i= 0; i < res.vectorsCount(); ++i)
    {
     
     //on recupere le vecteur i de mask et le vecteur i de res
      Vc::Mask<int> mask_i = mask_int.vector(i);
      Vc::int_v res_i = res.vector(i);
      
      //on determine la valeur du vecteur i de res en fonction du masque
      res_i(mask_i) = value_if_x1_lower_than_x2.data_.vector(i); 
      res_i(!mask_i) = value_otherwise.data_.vector(i);
      
      //on stocke le resultat dans le vecteur i de res
      res.vector(i) = res_i;
      
    }
    
    return res;

}

inline void SimdCompareAndSetIfLower(const Simd_float x_new, Simd_float x, 
				     const Simd_int i_new, Simd_int i)
{

  //on compare x1 et x2 
  Vc::Mask<float> mask = (x_new.data_ < x.data_);
  
  //on determine le nouveau x
  x.data_(mask) = x_new.data_;

  Vc::Memory<Vc::Mask<int>, Vc::Mask<float>::Size> mask_int;
  for (size_t j= 0; j < Vc::Mask<float>::Size; ++j) { mask_int[j] = mask[j]; }

  //on parcourt chaque vecteur qui compose i et on applique la selection dessus
  for (size_t j= 0; j < i.data_.vectorsCount(); ++j)
    {
     
      Vc::Mask<int> mask_j = mask_int.vector(j);
      //on determine la valeur du vecteur i de res en fonction du masque
      Vc::int_v i_at_j = i.data_.vector(j);  
      i_at_j(mask_j) = i_new.data_.vector(j); 
      i.data_.vector(j) = i_at_j;
    }
    

  // The code does this for each vector element:
  //if (x_new < x) {
  //  x = x_new;
  //  i = i_new;
  //}
  
}



#endif


